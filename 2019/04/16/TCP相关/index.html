<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="网络编程,">










<meta name="description" content="TCP服务提供一种面向连接的. 可靠的字节流服务. 面向连接意味着两个应用TCP的应用. 通常是一个客户端和一个服务端, 在彼此交换数据之前必须先建立一个TCP连接. 这一个过程与打电话很相似. 先拨号振铃, 等待对方说应答. 然后才说明是谁. TCP提供可靠性的方式 应用数据被分割成TCP认为最合适发送的数据块. 当TCP发出一个段后. 启动一个定时器. 等待目的全确认收这个报文段. 如果不能及">
<meta name="keywords" content="网络编程">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP相关">
<meta property="og:url" content="http://www.ten951.com/2019/04/16/TCP相关/index.html">
<meta property="og:site_name" content="读书与做事">
<meta property="og:description" content="TCP服务提供一种面向连接的. 可靠的字节流服务. 面向连接意味着两个应用TCP的应用. 通常是一个客户端和一个服务端, 在彼此交换数据之前必须先建立一个TCP连接. 这一个过程与打电话很相似. 先拨号振铃, 等待对方说应答. 然后才说明是谁. TCP提供可靠性的方式 应用数据被分割成TCP认为最合适发送的数据块. 当TCP发出一个段后. 启动一个定时器. 等待目的全确认收这个报文段. 如果不能及">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.ten951.com/images/TCP%E5%8C%85%E9%A6%96%E9%83%A8.png">
<meta property="og:image" content="http://www.ten951.com/images/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E7%BB%88%E6%AD%A2.png">
<meta property="og:image" content="http://www.ten951.com/images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE.png">
<meta property="og:image" content="http://www.ten951.com/images/%E6%8E%A5%E6%94%B6%E7%AB%AF%E7%AA%97%E5%8F%A3%E7%BB%93%E6%9E%84.png">
<meta property="og:updated_time" content="2019-08-07T07:31:43.897Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TCP相关">
<meta name="twitter:description" content="TCP服务提供一种面向连接的. 可靠的字节流服务. 面向连接意味着两个应用TCP的应用. 通常是一个客户端和一个服务端, 在彼此交换数据之前必须先建立一个TCP连接. 这一个过程与打电话很相似. 先拨号振铃, 等待对方说应答. 然后才说明是谁. TCP提供可靠性的方式 应用数据被分割成TCP认为最合适发送的数据块. 当TCP发出一个段后. 启动一个定时器. 等待目的全确认收这个报文段. 如果不能及">
<meta name="twitter:image" content="http://www.ten951.com/images/TCP%E5%8C%85%E9%A6%96%E9%83%A8.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '2K6UH4SOHI',
      apiKey: '2b03784fc9fa021dbe018fafc1c87584',
      indexName: 'articles',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.ten951.com/2019/04/16/TCP相关/">





  <title>TCP相关 | 读书与做事</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">读书与做事</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">优秀的普通人</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.ten951.com/2019/04/16/TCP相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ten951">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书与做事">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">TCP相关</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-16T15:45:51+08:00">
                2019-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/book/" itemprop="url" rel="index">
                    <span itemprop="name">book</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h2><p>提供一种面向连接的. 可靠的字节流服务. 面向连接意味着两个应用TCP的应用. 通常是一个客户端和一个服务端, 在彼此交换数据之前必须先建立一个TCP连接. 这一个过程与打电话很相似. 先拨号振铃, 等待对方说应答. 然后才说明是谁.</p>
<h3 id="TCP提供可靠性的方式"><a href="#TCP提供可靠性的方式" class="headerlink" title="TCP提供可靠性的方式"></a>TCP提供可靠性的方式</h3><ol>
<li>应用数据被分割成TCP认为最合适发送的数据块.</li>
<li>当TCP发出一个段后. 启动一个定时器. 等待目的全确认收这个报文段. 如果不能及时收到一个确认. 将重发这个报文段</li>
<li>当TCP收到发自TCP连接另一端的数据. 他将发送一个确认. 这个确认不是立即发送. 通常将推迟分之一秒.</li>
<li>TCP将保持它首部和数据的检验和. 这是一个端到端的检验和. 目的是检测数据在传输过程中的任何变化. 如果收到段的检验和有差错. TCP讲丢弃这个报文段和不确认收到此报文段(希望发送端超时并重发)</li>
<li>既然TCP报文段作为IP数据报来传输. 而IP数据报的到达可能会失序. 因此TCP报文段的到达也可能会失序. 如果必要. TCP将对收到的数据进行重新排序. 将收到的数据已正确的顺序交给应用层.</li>
<li>既然IP数据报会发生重复. TCP的接收端必须丢弃重复数据.</li>
<li>TCP还能提供流程控制. TCP链接的每一方都有固定大小的缓冲空间, TCP的接收端只允许另一端发送接收端缓冲区能接纳的数据. 这将防止较快的主机导致较慢的主机的缓存区溢出.<a id="more"></a>
<h3 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h3></li>
</ol>
<p><img src="/images/TCP%E5%8C%85%E9%A6%96%E9%83%A8.png" alt="Alternate text"></p>
<p>每个TCP段都包含源端和目的端的端口号. 用于寻找发端和收端应用进程. 这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接.</p>
<p>序号用来标识从TCP发端向TCP收端发送的数据字节流. 它标识在这个报文段中的的第一个数据字节, 如果将字节流看作在连个应用间的单向流动. 则TCP用序号对每个字节进行计数. 序号是32bit的无序号数. 序号到达2^32-1后又从0开始</p>
<p>当建立一个新的连接时. syn标志变1. 序号字段包含由这个主机选择的该连接的初始序号ISN. 该主机要发送数据的一个字节需要为这个ISN加1. 因为SYN标志消耗了一个序号.</p>
<p>既然每个传输的字节都被计数. 确认序号包含发送确认的一端所期望收到的下一个序号. 因此, 确认序号应当是上次已成功收到数据字节序号+1. 只有ACK标志位1时确认序号字段才有效</p>
<p>发送ACK无需任何代价. 因为32bit的确认序号字段和ACK标志一样. 总是TCP首部一部分. 一旦连接建立起来, 这个总是被设置. ACK标志也总是被设置为1</p>
<p>TCP为应用层提供双全工服务. 这意味数据能在两个方向上独立地进行传输, 连接的每一端必须保持每个方向上的传输数据序号.</p>
<p>TCP的流量控制有连接的每一端通过声明窗口大小来提供. 窗口大小为字节数. 其实与确认序号字段指明的值. 这个值是接收端端正期望接收的字节,</p>
<h3 id="TCP连接的建立和终止"><a href="#TCP连接的建立和终止" class="headerlink" title="TCP连接的建立和终止"></a>TCP连接的建立和终止</h3><p><img src="/images/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E7%BB%88%E6%AD%A2.png" alt="Alternate text"></p>
<h4 id="建立连接协议"><a href="#建立连接协议" class="headerlink" title="建立连接协议"></a>建立连接协议</h4><ol>
<li>主动开启者(通常称为客户端)发送一个SYN报文段, 并指明自己想要连接的端口号和它的客户端初始序列号(记为ISN(c)), 通常, 客户端还会借此发送一个或多个选项, 客户端发送的这个SYN报文段称做段1</li>
<li>服务器也发送自己的SYN报文段作为相应, 并包含了它的初始序列号(ISN(s)), 该段称作段2. 此外. 为了确认客户端的SYN, 服务器将其包含的ISN(c)+1后作为返回的ACK数值, 因此. 每发送一个SYN. 序列号就会自动+1. 这样如果出现丢失的情况, 该SYN段将会重传.</li>
<li>为了确认服务器的SYN, 客户端将ISN(s)+1后作为返回ACK. 这称之为段3</li>
</ol>
<p>这三个报文段完成链接的建立. 这个过程也称为三次握手.</p>
<h4 id="连接终止协议"><a href="#连接终止协议" class="headerlink" title="连接终止协议"></a>连接终止协议</h4><ol>
<li>连接的主动关闭者发送一个FIN段指明接受者希望看到的自己当前的序列号(K), FIN段还包含了一个ACK段用于确认对方最近一次发来的数据(L)</li>
<li>连接的被动关闭者将K+1作为相应的ACK值. 以表明它已经成功接收到主动关闭者发送的FIN, 此时. 上层的应用程序会被告知连接的另一端已经提出了关闭请求. 通常. 这将导致应用程序发起自己的关闭操作. 接着. 被动关闭者将身份转变为主动关闭者. 并发送自己的FIN, 该报文段的序列号为L.</li>
<li>为了完成连接的关闭. 最后发送的报文段还包含一个ACK用于确认上一个FIN. 值得注意的是. 如果出现FIN丢失的情况, 那么发送方将重新传输直到接收到一个ACK确认为止.</li>
</ol>
<p>关闭一个TCP连接需要4个报文段.</p>
<p>收到一个FIN只意味着在这一方向上没有数据流动. 一个TCP链接在收到一个FIN后仍能发送数据. 而这对利用半关闭的应用来说是可能的.尽管在实际应用中只有很少的. TCP应用程序这样做.</p>
<h4 id="TCP的半关闭"><a href="#TCP的半关闭" class="headerlink" title="TCP的半关闭"></a>TCP的半关闭</h4><p>TCP提供了连接的一端在结束它的发送后还能接受来自另一端数据的能力.</p>
<p>客户端发送完了自己的数据. 向服务端发送FIN. 服务端发送FIN的ack. 完成客户端半关闭. 意思是: 我没有数据发送了. 但是可以接收数据. 当服务端发送完数据. 发送一个FIN. 客户端返回FIN的ack. 完成服务端的关闭. 这是这个链接就彻底关闭了.</p>
<h4 id="同时打开"><a href="#同时打开" class="headerlink" title="同时打开"></a>同时打开</h4><p>两个应用程序同时彼此执行主动打开. 每一方必须发送一个SYN, 且这些SYN必须传递给对方. 这需要每一方使用一个对方熟知的端口作为本地端口. 这里双方互为客户端和服务端, 需要交换4个报文段. 比正常的三次握手多了一次</p>
<h4 id="同时关闭"><a href="#同时关闭" class="headerlink" title="同时关闭"></a>同时关闭</h4><p>通常一方发送一个FIN执行主动关闭. 双方都执行主动关闭也是有可能. TCP协议也允许这样的同时关闭</p>
<p>双方同时发送FIN, 并在收到FIN后. 发送ACK.</p>
<h4 id="初始序列号"><a href="#初始序列号" class="headerlink" title="初始序列号"></a>初始序列号</h4><p> TCP报文段在经过网络路由后可能会存在延迟抵达与排序混乱的情况。为了解决这一问题,需要仔细选择初始序列号。</p>
<p> 在发送用于建立连接的SYN之前,通信双方会选择一个初始序列号。初始序列号会随<br>时间而改变,因此每一个连接都拥有不同的初始序列号。 [RFCO793]指出初始序列号可被视<br>为一个32位的计数器。该计数器的数值每4微秒加10此举的目的在于为一个连接的报文段<br>安排序列号,以防止出现与其他连接的序列号重叠的情况。尤其对于同一连接的两个不同实<br>例而言,新的序列号也不能出现重叠的情况。</p>
<h4 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h4><table>
<thead>
<tr>
<th>种类</th>
<th>长度</th>
<th>名称</th>
<th>参考</th>
<th>描述与目的</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>EOL</td>
<td>[RFCO793]</td>
<td>选项列表结束</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>NOP</td>
<td>[RFCO793]</td>
<td>无操作(用于填充)</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>MSS</td>
<td>[RFCO793].</td>
<td>最大报文段大小</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>WSOPT</td>
<td>[RFCO1323]</td>
<td>窗日缩放因子(窗日左移量)</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>SACK-Pemitted</td>
<td>[RFCO2018]</td>
<td>发送者支持SACK选项</td>
</tr>
<tr>
<td>5</td>
<td>可变</td>
<td>SACk</td>
<td>[RFCO2018]</td>
<td>SACK阻塞(接收到乱序数据)</td>
</tr>
<tr>
<td>8</td>
<td>10</td>
<td>TSOPT</td>
<td>[RFco1323]</td>
<td>时间戳选项</td>
</tr>
<tr>
<td>28</td>
<td>4</td>
<td>UTO</td>
<td>[RFCO5482]</td>
<td>用户超时(一段空闲时间后的终止)</td>
</tr>
<tr>
<td>29</td>
<td>可变</td>
<td>TCP-AO</td>
<td>[RFCO5925]</td>
<td>认证选项(使用多种算法)</td>
</tr>
<tr>
<td>253</td>
<td>可变</td>
<td>Experimental</td>
<td>[RFcO4727]</td>
<td>保留供实验所用</td>
</tr>
<tr>
<td>254</td>
<td>可变</td>
<td>Experimental</td>
<td>[RFCO4727]</td>
<td>保留供实验所用</td>
</tr>
</tbody></table>
<h3 id="TCP超时与重传"><a href="#TCP超时与重传" class="headerlink" title="TCP超时与重传"></a>TCP超时与重传</h3><p>TCP在发送数据时会设置一个计时器,若至计时器超时仍未收到数据确认信息,则会引<br>发相应的超时或基于计时器的重传操作,计时器超时称为重传超时(RTO)。另一种方式的重<br>传称为快速重传,通常发生在没有延时的情况下。若TCP累积确认无法返回新的ACK,或<br>者当ACK包含的选择确认信息(SACK)表明出现失序报文段时,快速重传会推断出现丢<br>圃 包。通常来说,当发送端认为接收端可能出现数据丢失时,需要决定发送新(未发送过的)<br>数据还是重传</p>
<h4 id="设置重传超时"><a href="#设置重传超时" class="headerlink" title="设置重传超时"></a>设置重传超时</h4><p>TCP超时和重传的基础是怎样根据给定连接的RTT设置RTO. 若TCP先于RTT开始重传. 可能会在网络中引起不必要的重复数据.反之. 真个网络利用率会随之下降.</p>
<p>TCP在收到数据后返回确认信息. 因此可在该信息中携带一个字节的数据来测量传输改确认信息所需的时间. 每个此类的测量结果称为RTT样本. TCP首先需要根据一段时间内的样本值建立好估计值. 第二步是基于估计值设置RTO. RTO设置得当是保证TCP性能的关键.</p>
<p>每个TCP连接的RTT均独立计算. 并且重传计时器会对任何占用序列号的在传数据计时(包含SYN和FIN).</p>
<h4 id="基于计时器的重传"><a href="#基于计时器的重传" class="headerlink" title="基于计时器的重传"></a>基于计时器的重传</h4><p>一旦TCP发送端得到了基于时间变化的RTT测量值,就能据此设置RTO,发送报文段时应确保重传计时器设置合理。在设定计时器前,需记录被计时的报文段序列号,若及时收到了该报文段的ACR,那么计时器被取消。之后发送端发送一个新的数据包时,需设定一个新的计时器,并记录新的序列号。因此每一个TCP连接的发送端不断地设定和取消一个重传计时器;如果没有数据丢失,则不会出现计时器超时。</p>
<p>若在连接设定的RTO内, TCP没有收到被计时报文段的ACK,将会触发超时重传。TCP将超时重传视为相当重要的事件,当发生这种情况时,它通过降低当前数据发送率来对此进行快速响应。实现它有两种方法:</p>
<ol>
<li>第一种方法是基于拥塞控制机制减小发送窗口大小;</li>
<li>另一种方法为每当一个重传报文段被再次重传时,则增大RTO的退避因子,即<strong>Kam算法的“第二部分”</strong>。特别是当同一报文段出现多次重传时, RTO值(暂时性地)乘上值y来形成新的超时退避值:</li>
</ol>
<blockquote>
<p>RTO=yRTO</p>
</blockquote>
<p>在通常环境下, y值为1. 随着多次重传, y呈加倍增长‥ 2, 4, 8,等等。通常y不能超过最大退避因子(Linux确保其RTO设置不能超过TCP_RTO_MAX,其默认值为120s)。<br>一旦接收到相应的ACK, y会重置为1.</p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传机制[RFc5681]基于接收端的反馈信息来引发重传,而非重传计时器的超时。因此与超时重传相比,快速重传能更加及时有效地修复丢包情况。典型的TCP同时实现了两者。在详细讨论快速重传前,首先需要了解当接收到失序报文段时, TCP需要立即生成确认信息(重复ACK),并且失序情况表明在后续数据到达前出现了丢段,即接收端缓存出现了空缺。发送端的工作即为尽快地、高效地填补该空缺。</p>
<p>当失序数据到达时,重复Ack应立即返回,不能延时发送。原因在于使发送端尽早得知有失序报文段,并告诉其空缺在哪。当采用SACK时,重复ACK通常也包含SACK信息,利用该信息可以获知多个空缺。</p>
<p>重复ACK到达发送端表明先前发送的某个分组已丢失. 重复ACK也可能在另一种情况下出现. 即当网络中出现失序分组时—-若接受端收到氮气期盼序列号的后续分组时, 当前期盼的包可能丢失. 也可能延时到达. 通常是无法得知是那种情况的. TCP等待一定数目的重复ACK(dupthresh). 来决定数据是否丢失并触发快速重传. 通常这个阈值为3.</p>
<p>快速重传算法可以概括如下: <strong>TCP发送端在观测到至少dupthresh个重复ACK后,即重传可能丢失的数据分组,而不必等到重传计时器超时。当然也可以同时发送新的数据。根据重复ACk推断的丢包通常与网络拥塞有关,因此伴随快速重传应触发拥塞控制机制。不采用SACK时,在接收到有效ACK前至多只能重传一个报文段。采用SACK,ACK可包含额外信息,使得发送端在每个RTT时间内可以填补多个空缺。</strong></p>
<h4 id="带选择确认的重传"><a href="#带选择确认的重传" class="headerlink" title="带选择确认的重传"></a>带选择确认的重传</h4><p>TCP接收端可提供SACK功能. 通过TCP头部的累积ACK号字段来描述其接收到的数据. ACK号与接收端缓存中的其他数据之间的间隔称为空缺. 序列号高于空缺的数据称为失序数据. 因为这些数据和之前接收的序列号不连续.</p>
<p>SACK信息中包含</p>
<p>left edge:  不连续块的第一个报文段的序列号</p>
<p>right edge: 不连续块的最后一个报文段的序列号之后的序列号;</p>
<p>TCP发送端的任务是通过重传丢失的数据来填补接收端缓存中的空缺. 但同时也尽可能不重传以正确接收到的数据.</p>
<h5 id="SACK接收端行为"><a href="#SACK接收端行为" class="headerlink" title="SACK接收端行为"></a>SACK接收端行为</h5><p>接收端在TCP连接期间收到SACK许可选项即可生成SACK.通常来说. 每当缓存中存在失序数据时 接收端就可生成SACK. 导致数据失序的原因可能是由于传输过程中丢失. 也可能是新数据先于旧数据到达.</p>
<p>第一个SACK块内包含的是<strong>最近接受到的(most recently received)报文段的序列号范围</strong>. 最近的一个块中包含的内容除了包含最新接收的序列号信息. 还需重复之前的SACK块. 这样做的目的是防止SACK丢失.</p>
<h5 id="SACK发送端行为"><a href="#SACK发送端行为" class="headerlink" title="SACK发送端行为"></a>SACK发送端行为</h5><p>尽管一个支持SACK的接收端可通过生成合适的SACK信息来充分利用SACK,但还不足以使该TCP连接充分利用SACK功能。在发送端也应提供SACK功能,并且合理地利用接收到的SACK块来进行丢失重传,该过程也称为<strong>选择性重传( selective retransmission)或选择性重发(selective repeat)</strong>. SACK发送端记录接收到的累积ACK信息(像大多数TCP发送端一样),还需记录接收到的SACK信息,并利用该信息来避免重传正确接收的数据。</p>
<p>一种方法是当接收到相应序列号范围的ACK时,则在其重传缓存中标记该报文段的选择重传成功。</p>
<p><strong>当SACK发送端执行重传时,通常是由于其收到了SACK或重复ACK,它可以选择发送新数据或重传旧数据, SACR信息提供接收端数据的序列号范围,因此发送端可据此推断需要重传的空缺数据。最简单的方法是使发送端首先填补接收端的空缺,然后再继续发送新数据[RFc3517] (若拥塞控制机制允许)。这也是最常用的方法.</strong></p>
<h5 id="伪超时与重传"><a href="#伪超时与重传" class="headerlink" title="伪超时与重传"></a>伪超时与重传</h5><p>在很多情况下. 即使没有出现数据丢失也可能引发重传. 这种不必要的重传就是伪重传. 其主要造成的原因是伪超时. 即过早判定超时. 其他因素如包失序. 包重复. 或ACK丢失也能导致该现象. 在实际RTT显著增长, 超时当前RTO时. 可能出现伪超时.</p>
<h5 id="重复SACK-DSACK-拓展"><a href="#重复SACK-DSACK-拓展" class="headerlink" title="重复SACK(DSACK)拓展"></a>重复SACK(DSACK)拓展</h5><p>在非SACK的TCP中, ACK只能想发送端告知最大的有序报文段. 采用SACK则可告知其他的失序报文段. 基本的SACK机制对接收端收到重复护具端时怎么运作没有规定. 这些重复数据可能是伪重传. 网络中的重复或其他原因造成的.</p>
<p><strong><em>在SACK接收端采用DSACK (或称作D-SACK),即重复SACK[RFC2883],并结合通常的SACK发送端,可在第一个SACK块中告知接收端收到的重复报文段序列号. DSACK的主要目的是判断何时的重传是不必要的,并了解网络中的其他事项。因此发送端至少可以推断是否发生了包失序、ACk丢失、包重复或伪重传.</em></strong></p>
<h4 id="包失序和包重复"><a href="#包失序和包重复" class="headerlink" title="包失序和包重复"></a>包失序和包重复</h4><h5 id="失序"><a href="#失序" class="headerlink" title="失序"></a>失序</h5><p>区分丢包与失序不是一个很重要的问题。要解决它需要判断发送端是否已经等待了足够长的时间来填补接收端的空缺。幸运的是,互联网中严重的失序并不常见[JO3],因此将dupthresh设为相对较小值(如缺省值为3)就能处理绝大部分情况。即便如此,还是有很多研究致力于调整TCP行为来应对严重失序[LLYO7]。有些方法可动态调整dupthresh,如Linux的TCP实现.</p>
<h5 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h5><p> 利用SACK特别是DSACK, 就可以简单的忽略这个问题.</p>
<h3 id="TCP数据流与窗口管理"><a href="#TCP数据流与窗口管理" class="headerlink" title="TCP数据流与窗口管理"></a>TCP数据流与窗口管理</h3><h4 id="延时确认"><a href="#延时确认" class="headerlink" title="延时确认"></a>延时确认</h4><p>在很多情况下. TCP并不对每个到来的数据包都返回ACK, 利用TCP的累积ACK字段就能实现该功能, 累积确认可以允许TCP延迟一段时间发送ACK, 以便将ACK和相同方向上需要传的数据结合发送. 这种捎带传输的方法经常用于批量数据传输. 显然TCP不能任意时长地延迟ACK, 否则对方会误认为数据丢失而出现不必要的重传.</p>
<p>采用延时ACK方法会减少ACK传输数据. 可以一定程度地减轻网络负载.</p>
<h4 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h4><p>算法要求. 当一个TCP链接中有在传数据. 小的报文段(长度小于MISS)就不能发送. 直到所有的在传数据都收到ACK, 并且在收到ACK后. TCP需要收集这些小数据. 将其整合到一个报文段中发送. 这种方法迫使TCP遵守停等规程. 只有等接收到所有在传数据的ACK后才能继续发送. 算法的精妙之处在于实现了自时钟控制. ACK返回越快. 数据传输也越快.</p>
<h4 id="流量控制与窗口管理"><a href="#流量控制与窗口管理" class="headerlink" title="流量控制与窗口管理"></a>流量控制与窗口管理</h4><h5 id="TCP的滑动窗口协议有什么用"><a href="#TCP的滑动窗口协议有什么用" class="headerlink" title="TCP的滑动窗口协议有什么用"></a>TCP的滑动窗口协议有什么用</h5><p>依靠发送确认. 设置RTO. 超时重传机制. 保证TCP协议是可靠的. 但效率不太高.如果从发送方到接收方传递即使一个很小的分组都要用很长时间(推迟或延迟)的话(如一秒或两秒,对卫星链路来说并非不正常),考虑一下那会怎样。发送方可以注人一个分组到通信路径,然后停下来等待直到它收<br>到ACk.这个协议因此被称为“停止和等待” 。假设没有分组在传输中丢失和无可挽回地损害,该协议的吞吐量性能(每单位时间发送在网络中的数据量)与M/R成正比, M是分组大小, R是往返时间(RTT)。如果有分组丢失和损害的话,情况甚至更糟糕: “吞吐质” (每单位时间传送的有用数据量)明显要比吞吐量要低。</p>
<p>对于不会损害和丢失太多分组的网络来说,低吞吐量的原因是网络经常没有处于繁忙状态。情况与使用装配流水线时不出一个完整产品就不准新的工作进人类似。流水线大部分时间是空闲的。我们进一步对比,很明显,如果我们允许同一时间有多个工作单元进人流水线,就可以做得更好。对网络通信来说也是一样的一如果我们允许多个分组进人网络,就可以使它“更繁忙”,从而得到更高的吞吐量。</p>
<p>很明显,允许多个分组同时进人网络使事情变得复杂。现在发送方必须不仅要决定什么时间注人一个分组到网络中,还要考虑注人多少个。并且必须要指出在等待ACK时,怎样维持计时器,同时还必须要保存每个还没确认的分组的一个副本以防需要重传。接收方需要有一个更复杂的ACK机制:可以区分哪些分组已经收到,哪些还没有。接收方可能需要一个更复杂的缓存(分组保存)机制一允许维护“次序杂乱”的分组(那些比预想要先到的分组更早到达的分组,因为丢包和次序重排的原因),除非简单地抛弃这些分组,而这样做是很没效率的。还有其他一些没有这么明显的问题。如果接收方的接收速率比发送方的发送速率要慢怎么办?如果发送方简单地以很高的速率发送很多分组,接收方可能会因处理或内存的限制而丢掉这些分组。中间的路由器也会有相同的间题。如果网络基础设施处理不了发送方和接收方想要使用的数据发送率怎么办? 为了解决这些问题. 引入了滑动窗口协议.</p>
<h5 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h5><p>TCP连接的每一端都可收发数据. 连接的收发数据量是通过一组窗口接口来维护的. 每个TCP活动连接的两端都维护一个发送窗口结构和接收窗口结构.</p>
<p><img src="/images/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE.png" alt="Alternate text"></p>
<p>TCP以字节(而非包)为单位维护其窗口结构。已标号为2 - 11字<br>节。由接收端通告的窗日称为提供窗口(oiferedwindow),包含4 - 9字节。接收端已成功确认包括第3字节在内的之前的数据,并通告了一个6字节大小的窗日。窗口大小字段相对ACK号有一个字节的偏移量。发送端计算其可用窗口,即它可以立即发送的数据量。可用窗口计算值为提供窗日大小减去在传(已发送但未得到确认)的数据值.<br>变量SND.UNA和SND.WND分别记录窗日左边界和提供窗口值.SND.NXT则记录下次发送的数据序列号,因此可用窗日值等于(SND.UNA+ SND.WND - SND.NXT)。</p>
<p>随着时间的推移,当接收到返回的数据ACK,滑动窗口也随之右移。窗口两端的相对运动使得窗口增大或减小。可用三个术语来描述窗日左右边界的运动:</p>
<ol>
<li>关闭(close),即窗日左边界右移。当已发送数据得到ACK确认时,窗日会减小0</li>
<li>打开(open),即窗口右边界右移,使得可发送数据量增大。当已确认数据得到处理,<br>接收端可用缓存变大,窗日也随之变大0</li>
<li>收缩(shrink),即窗口右边界左移。主机需求RFC [RFCl122]并不支持这一做法,但TCP必须能处理这一问题.</li>
</ol>
<p>每个TCP报文段都包含ACK号和窗口通告信息, TCP发送端可以据此调节窗口结构。窗口左边界不能左移,因为它控制的是已确认的ACK号,具有累积性,不能返回。当得到的ACK号增大而窗口大小保持不变时(通常如此),我们就说窗口向前“滑动”。若随着ACK号增大窗日却减小,则左右边界距离减小。当左右边界相等时,称之为零窗日。此时发送端不能再发送新数据。这种情况下, TCP发送端开始探测(probe)对方窗口,伺机增大提供窗口。</p>
<p>接收端也维护一个窗口结构. 但比发送端窗口简单. 该窗口结构记录了已接收并确认的数据. 已经它能够接收的最大序列号. 该窗口可以保证其接收数据的正确性. 特别是. 接收端希望避免存储重复的已接收和确认的数据. 以及避免存储不应该接收的数据(超过发送方右窗口便捷的数据)<br>下图描述了接收窗口结构</p>
<p><img src="/images/%E6%8E%A5%E6%94%B6%E7%AB%AF%E7%AA%97%E5%8F%A3%E7%BB%93%E6%9E%84.png" alt="Alternate text"></p>
<p>与发送端窗口一样,该窗口结构也包含一个左边界和右边界,但窗口内的字节(图中的4 - 9字节)并没有区分。对接收端来说,到达序列号小于左窗日边界(称为RCV.NXT),被认为是重复数据而丢弃,超过右边界(RCV.WND + RCV.NXT)的则超出处理范围,也被丢弃。注意到由于TCP的累积ACK结构,只有当到达数据序列号等于左边界时,数据才不会<br>被丢弃,窗口才能向前滑动。对选择确认TCP来说,使用SACK选项,窗口内的其他报文段也可以被接收确认,但只有在接收到等于左边界的序列号数据时,窗口才能前移.</p>
<h4 id="零窗口与TCP持续计时器"><a href="#零窗口与TCP持续计时器" class="headerlink" title="零窗口与TCP持续计时器"></a>零窗口与TCP持续计时器</h4><p>TCP是通过接收端的通告窗口来实现流量控制的。通告窗口指示了接收端可接收的数据量。当窗口值变为0时,可以有效阻止发送端继续发送,直到窗口大小恢复为非零值。当接收端重新获得可用空间时,会给发送端传输一个窗口更新(window update),告知其可继续发送数据。这样的窗口更新通常都不包含数据(为“纯ACK” ),不能保证其传输的可靠性。</p>
<p>因此TCP必须有相应措施能处理这类丢包。如果一个包含窗口更新的ACK丢失,通信双方就会一直处于等待状态.接收方等待接收数据(已将窗口设为非零值),发送方等待收到窗口更新告知其可继续发送。为防止这种死锁的发生,发送端会采用一个<strong>持续计时器</strong>间歇性地查询接收端,看其窗口是否已增长。持续计时器会触发窗口探测(window probe)的传输,强制要求接收端返回ACK (其中包含了窗口大小字段)。主机需求RFC[RFCl122]建议在一个RTO之后发送第一个窗口探测,随后以指数时间间隔发送.</p>
<h3 id="TCP阻塞控制"><a href="#TCP阻塞控制" class="headerlink" title="TCP阻塞控制"></a>TCP阻塞控制</h3><p>为了防止网络因为大规模的通信负载而瘫痪. 其基本方法就是当有理由认为网络即将进入阻塞状态时减缓TCP传输, 难点在于怎样准确的判断何时需要减缓且如何减缓TCP传输.以及何时恢复其原有的速度.</p>
<p>TCP的流量控制机制完成了对发送速率的调节. 它是基于ACK数据包中的通告窗口大小字段来实现的. 避免接收方缓存溢出.</p>
<h4 id="拥塞检测"><a href="#拥塞检测" class="headerlink" title="拥塞检测"></a>拥塞检测</h4><p>针对丢包情况, TCP采取的首要机制是重传.包括超时重传和快速重传. 但当网络处于阻塞崩溃状态时. 超时重传就是火上浇油.</p>
<p>在发送端进入一个窗口控制变量cwnd, 接收端通知窗口awnd, 发送端实际可用窗口W.</p>
<blockquote>
<p>W=min(cwnd,awnd)<br>还没有收到ACK回复的数据量不能多于W(以包或字节为单位).</p>
</blockquote>
<p>这是合乎逻辑的. 但实际情况并不如此. 因为网络和接收状况会随实际变化. 相应地awnd和cwnd的数组也会随之改变. TCP发送方无法直接获得cwnd的<em>准确</em>值. 因此W, cwnd, awnd的值都要根据经验设定并需动态调节. 我们希望W的值接近最佳窗口大小. W反应网络中可存储待发送数据量的大小. 如何确定W的值也就是BDP是难点.</p>
<h5 id="经典的算法"><a href="#经典的算法" class="headerlink" title="经典的算法"></a>经典的算法</h5><p>在新TCP建立之初. 还无法获知可用的传输资源. cwnd的初始值无法确定. TCP通过与接收端交换一个数据包就能获得awnd值. 获得cwnd的最佳值的唯一方法是以越来越快的速率不断发送数据. 直到出现丢包未止. 这时考虑立即以可用的最大速度发送或者慢速启动发送. 由于多个TCP连接共享一个网络传输. 以全速启动会影响其他连接的传输性能, 所以通常会有特定的算法来避免过快启动. 直至稳定传输后才会运行其他算法</p>
<h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>当一个新的TCP连接建立或检测到由重传超时(RTO)导致的丢包时. 需要执行慢启动. TCP发送端长时间处于空闲状态也可能调用慢启动算法. <em>目的是使TCP在用阻塞避免搜寻更多可用宽带之前得到cwnd值, 以及帮助TCP建立ACK时钟, 通常TCP在建立新连接时执行慢启动. 直至有丢包. 执行拥塞算法进入稳定状态</em></p>
<p>TCP以发送一定数目的数据段开始慢启动. 称为初始窗口IW. IW的初始值为一个SMSS(发送方的最大段大小). 在没有出现丢包的情况且每个数据包都用相应的ACK. 第一个数据段的ACK到达. 继续发送一个新的数据段, 每收到一个好的ACK(大于之前的ACK)响应. 慢启动算法以<em>min(N,SMSS)</em>来增加cwnd值. 这里的N是值未经确定的传输数据中能通过这一<em>好的ACK</em>确认的字节数.</p>
<p>增长公式为w=2的k次方. 当检测到网络瘫痪.cwnd将大幅度减少(减至原值一半). 这是TCP右慢启动阶段进入阻塞避免阶段的转折点.与cwnd和慢启动阈值相关.</p>
<p>当发生ACK延时, cwnd仍以指数增长. 但增幅较小.</p>
<h5 id="阻塞避免"><a href="#阻塞避免" class="headerlink" title="阻塞避免"></a>阻塞避免</h5><p>在慢启动阶段. cwnd的值快速增长. 一旦达到阈值(ssthresh). TCP会进入避免阻塞阶段. swnd每次的增长值近似于成功传输的数据段大小. 这种随时间线性增长方式与慢启动指数增长相比要缓慢很多. 每接收一个新的ACK, cwnd会更新为:cwnd(t-1) = cwnd(t)+SMSS*SMSS/cwnd(t)</p>
<p>当发生ACK延时. cwnd也会增长. 但增幅很小.</p>
<p>慢启动和阻塞避免的选择问题. 就是cwnd和ssthresh的关系问题. cwnd &lt; ssthresh 启用慢启动 cwnd &gt; ssthresh 执行阻塞避免; 两者相等. 任何一种都行. ssthresh也不是固定的. 这个值的初始值可以任意设置. 这会使得TCP总是以慢启动状态开始传输. 当有重传情况发生时. 无论是超时重传还是快速重传. ssthresh会改变. 值将减小至当前窗口大小的一半. 但是不会小于2*SMSS.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/网络编程/" rel="tag"># 网络编程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/02/图一/" rel="next" title="图一">
                <i class="fa fa-chevron-left"></i> 图一
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/18/DNS解析/" rel="prev" title="DNS解析">
                DNS解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ten951</p>
              <p class="site-description motion-element" itemprop="description">学习工作技能,感悟生活细节</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ten951" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:wangyongtian520@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP服务"><span class="nav-number">1.</span> <span class="nav-text">TCP服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP提供可靠性的方式"><span class="nav-number">1.1.</span> <span class="nav-text">TCP提供可靠性的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP首部"><span class="nav-number">1.2.</span> <span class="nav-text">TCP首部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP连接的建立和终止"><span class="nav-number">1.3.</span> <span class="nav-text">TCP连接的建立和终止</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#建立连接协议"><span class="nav-number">1.3.1.</span> <span class="nav-text">建立连接协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连接终止协议"><span class="nav-number">1.3.2.</span> <span class="nav-text">连接终止协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP的半关闭"><span class="nav-number">1.3.3.</span> <span class="nav-text">TCP的半关闭</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同时打开"><span class="nav-number">1.3.4.</span> <span class="nav-text">同时打开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同时关闭"><span class="nav-number">1.3.5.</span> <span class="nav-text">同时关闭</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始序列号"><span class="nav-number">1.3.6.</span> <span class="nav-text">初始序列号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP选项"><span class="nav-number">1.3.7.</span> <span class="nav-text">TCP选项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP超时与重传"><span class="nav-number">1.4.</span> <span class="nav-text">TCP超时与重传</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#设置重传超时"><span class="nav-number">1.4.1.</span> <span class="nav-text">设置重传超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于计时器的重传"><span class="nav-number">1.4.2.</span> <span class="nav-text">基于计时器的重传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速重传"><span class="nav-number">1.4.3.</span> <span class="nav-text">快速重传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带选择确认的重传"><span class="nav-number">1.4.4.</span> <span class="nav-text">带选择确认的重传</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SACK接收端行为"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">SACK接收端行为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SACK发送端行为"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">SACK发送端行为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#伪超时与重传"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">伪超时与重传</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重复SACK-DSACK-拓展"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">重复SACK(DSACK)拓展</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包失序和包重复"><span class="nav-number">1.4.5.</span> <span class="nav-text">包失序和包重复</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#失序"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">失序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重复"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">重复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP数据流与窗口管理"><span class="nav-number">1.5.</span> <span class="nav-text">TCP数据流与窗口管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#延时确认"><span class="nav-number">1.5.1.</span> <span class="nav-text">延时确认</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nagle算法"><span class="nav-number">1.5.2.</span> <span class="nav-text">Nagle算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流量控制与窗口管理"><span class="nav-number">1.5.3.</span> <span class="nav-text">流量控制与窗口管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP的滑动窗口协议有什么用"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">TCP的滑动窗口协议有什么用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#滑动窗口"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">滑动窗口</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#零窗口与TCP持续计时器"><span class="nav-number">1.5.4.</span> <span class="nav-text">零窗口与TCP持续计时器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP阻塞控制"><span class="nav-number">1.6.</span> <span class="nav-text">TCP阻塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#拥塞检测"><span class="nav-number">1.6.1.</span> <span class="nav-text">拥塞检测</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#经典的算法"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">经典的算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#慢启动"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">慢启动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#阻塞避免"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">阻塞避免</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ten951</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        


<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500682921");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>






        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  

  
  

  

  

  

</body>
</html>
